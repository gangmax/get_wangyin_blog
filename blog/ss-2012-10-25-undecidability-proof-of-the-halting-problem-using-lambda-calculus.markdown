# Undecidability proof of the halting problem using lambda calculus

From [here](https://yinwang1.substack.com/p/halting).

<span>As a teaching assistant for a graduate level "Theory of Computation" course, I don't understand why we use Turing machines as a model for all the computability and complexity theorems. It is much easier if we just use arguments on functions in a usual programming language. One good choice of such a language is the</span> [lambda calculus](https://en.wikipedia.org/wiki/Lambda_calculus)<span>. Basically, a function in lambda calculus is equivalent to a Turing machine. The "halting" of a Turing machine is equivalent to the corresponding lambda calculus term reducing to its "normal form". From this viewpoint, I came up with the following undecidability proof of the halting problem using the lambda calculus.</span> **Proof**<span>. Suppose that we have a function </span>`Halting(M,w),`<span> a </span>_hypothetical solver_ <span>for the halting problem.</span>`Halting`<span>takes two arguments, a function</span> `M` <span>and its input</span> `w`<span>, and it tells you whether or not</span> `M(w)`<span> will output </span>`True`<span>. Note that although</span> `M` <span>may go into infinite loops, never will our magical solver</span>`Halting`<span>. </span>`Halting` <span>always returns</span> `True` <span>or</span>`False`<span> within finite amount of time. Now we show a simple contradiction, which proves that the magical solver </span>`Halting` <span>cannot really exist. This question is: Does the following expression</span>`E`<span> returns </span>`True` <span>or</span> `False`<span>?</span>

> `E = Halting(λm.not(Halting(m,m)), λm.not(Halting(m,m)))`

<span>It turns out that this question cannot be answered. If E returns True, then we apply the function</span> `λm.not(Halting(m,m))` <span>to its argument</span> `λm.not(Halting(m,m))`<span>, and we get</span>

> `not(Halting(λm.not(Halting(m,m)), λm.not(Halting(m,m))))`

<span>Alas, this is exactly the negation of the original expression</span> `E`<span>, which means </span>`E` <span>should be False. This is a contradiction (or call it a "paradox" if you like), which shows that the halting problem solver</span>`Halting` <span>cannot exist, which means that the halting problem cannot be solved.</span> **QED**<span>. To connect back to usual computing theory terminology (as in Sipser's classic</span> [textbook](http://www.amazon.com/Introduction-Theory-Computation-Michael-Sipser/dp/113318779X)<span>), the functions</span> `Halting` <span>and</span> `M` <span>corresponds to two Turing machines, one of which taking the other as an argument.</span>`True` <span>corresponds to a Turing machine reaching its</span>_accept_<span>state, and</span> `False` <span>corresponds to reaching the</span>_reject_ <span>state. I'm surprised how much shorter this proof is as compared to [Church</span> [1935](https://www.ics.uci.edu/~lopes/teaching/inf212W12/readings/church.pdf)<span>,</span> [1936](https://users.fit.cvut.cz/~staryja2/MIVYC/church-a-note-on-the-entscheidungsproblem.pdf)<span>] and [Turing</span> [1936](https://www.cs.virginia.edu/~robins/Turing_Paper_1936.pdf)<span>]. Actually what I did in the proof was just making a</span> _loop_<span> in a circuit. Almost every logical paradox has a loop involved--pretty much the same kind of loop, the </span>[Möbius strip](https://en.wikipedia.org/wiki/M%C3%B6bius_strip)<span>. Every logic question expects the answer to be one of two sides--either True or False, but the Möbius strip has only one side! If you hope to learn more on related stuff, a nice </span>[book](http://www.diku.dk/~neil/comp2book2007/book-whole.pdf)<span>by Neil Jones shows that you can prove every theorem in theory of computation (including computability and complexity) using a simple programming language. It's not really necessary to use Turing machines for theory of computation. Turing machines make things awkward and complicated. Now, a fun exercise question may be, what is the connection between the above expressions E with the</span> [Y combinator](http://yinwang0.wordpress.com/2012/04/09/reinvent-y)<span>?</span>

> `λf.(λx.f(x x)) (λx.f(x x))`
